#+TITLE: Einstellungen Configuration
* package.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments link
:END:
Package loading
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
#+end_src
#+begin_src emacs-lisp
(package! aggressive-indent-mode)
(package! eval-in-repl)
(package! four-modifier :recipe (:host github :repo "sieman/four-modifier"))
(package! neo-layout-fly-keys :recipe (:host github :repo "sieman/neo-layout-fly-keys"))
(package! ox-confluence-en :recipe (:host github :repo "correl/ox-confluence-en"))
(package! ox-epub)
(package! ox-jira :recipe (:host github :repo "stig/ox-jira.el"))
(package! xah-fly-keys :recipe (:host github :repo "xahlee/xah-fly-keys"))
(package! ecb :recipe (:host github :repo "ecb-home/ecb"))
#+end_src

;; (package! rg) ; not using it at the moment
;; https://github.com/rougier/elegant-emacs (package! elegant-emacs :recipe (:host github :repo "rougier/elegant-emacs"))
;;(package! meow)                         ; is a modal keybinding system like xah-fly-keys and evil

* Appearance :appearance:

#224FBC Blauer Hintergrund wie Ocean

** Theme
#+begin_src emacs-lisp
(setq doom-theme 'doom-one)
(custom-set-faces
 '(show-paren-match ((t (:background "black" :foreground "yellow" :inverse-video t :weight bold))))
 '(region ((t (:foreground "#f1c40f" :background "#2c3e50" :inverse-video t))))
 `(cursor ((t (:foreground "white" :background "red")))))
;; All themes are safe to load
(setq custom-safe-themes t)
;; Color the border of windows according to the `highlight' color of the doom's theme
(add-hook! 'doom-load-theme-hook
           ;; A more visible window border
           ;; (set-face-attribute 'vertical-border nil :foreground (doom-color 'highlight))
           ;; Flycheck errors use the color of functions
           (after! flycheck
             (set-face-attribute 'flycheck-error nil
                                 :underline `(:color ,(doom-color 'functions)
                                              :style wave))))
#+end_src
** Cursor
#+begin_src emacs-lisp
(custom-set-variables '(cursor-type 'box))
#+end_src

** Dashboard
#+begin_src emacs-lisp
;; Splash image
(setq fancy-splash-image (concat doom-private-dir "thenwhyworry.png")
      +doom-dashboard-banner-padding '(0 . 1))
;; Hide the menu for as minimalistic a startup screen as possible.
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
#+end_src
** Buffer
#+begin_src emacs-lisp
;; Main theme
;; (setq doom-theme 'doom-dracula)

(setq display-line-numbers-type nil)

;; (display-time-mode t)
(setq display-time-24hr-format t)
(setq display-line-numbers-type nil)

;;(load! "~/.emacs.secrets")
;;(setq fill-column  sim-hard-wrap-at)

;; Select and raise the frame, always
;;(select-frame-set-input-focus (selected-frame))
#+end_src
** Prety Symbol Mode Disable
https://github.com/hlissner/doom-emacs/issues/1807

#+begin_src emacs-lisp
                                        ;(setq +pretty-code-enabled-modes nil)
;; or
                                        ;(remove-hook 'after-change-major-mode-hook #'+pretty-code-init-pretty-symbols-h)
;; (setq! +ligatures-composition-alist nil)
#+end_src
** Which Key Mode
#+begin_src emacs-lisp
(after! which-key
  (setq which-key-side-window-max-width 0.44
        which-key-max-display-columns 2
        which-key-side-window-max-height 0.26
        which-key-max-description-length 90)
  (which-key-setup-side-window-right-bottom))
#+end_src
** Modeline
#+begin_src emacs-lisp
(after! doom-modeline
  (require 'doom-modeline)
  (setq doom-modeline-modal-icon nil)
  ;; https://github.com/hlissner/doom-emacs/issues/2967
  (setq all-the-icons-scale-factor 1.1) ;; orignal val 1.2

  (custom-set-faces!
    '(mode-line :family "Iosevka SS04" :height 0.96)
    '(mode-line-inactive :family "Iosevka SS04" :height 0.96))

  (message "doom-modeline is loaded. :-)"))
#+end_src
** Fonts
;; "JetBrains Mono"
;; "LFBONovelNetz" "LOB.Novellenschrift" "LOV.Novellenschrift" "LUC.NovellenschriftU1A"
;; "Iosevka" "Iosevka Fixed" "Iosevka Term" "Iosevka SS04"
;; "Source Code Variable"
;; "Overpass Nerd Font"
;; https://github.com/Lindydancer/font-lock-studio debugging font
;; https://tecosaur.github.io/emacs-config/config.html#font-face
#+begin_src emacs-lisp
;; (print (font-family-list))

(setq doom-font (font-spec :family "Iosevka SS04" :style "Thin" :size 13)
      ;; doom-variable-pitch-font (font-spec :family "LOV.Novellenschrift" :size 20)
      doom-big-font (font-spec :family "Iosevka SS04" :style "Bold" :size 20))

(after! doom-themes
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t))

(custom-set-faces!
  '(font-lock-comment-face :slant italic)
  '(font-lock-keyword-face :slant italic))
#+end_src

* Einstellungen Modus Anwendungen :settings:modes:
** Calendar
#+begin_src emacs-lisp
(load! "sim-calendar")
(require 'sim-calendar)
(set-language-environment "German")
(set-locale-environment "de_DE.UTF-8")
#+end_src
** Rechtschreibprüfung :spell:checking:

npm install dictionary-en-gb

#+begin_src emacs-lisp
(setq ispell-dictionary "de_DE")
(setq ispell-hunspell-dict-paths-alist
      '(
        ("de_DE" "~/Library/Spelling/de_DE.aff")
        ("en_GB" "~/Library/Spelling/en_GB.aff")
        ))
#+end_src
** Tastaturlayout :keyboard:layout:
#+begin_src emacs-lisp
(require 'four-modifier)
;;(load! "+neo-layout.el")
#+end_src
** TODO AI Auto Compleation
[[https://github.com/TommyX12/company-tabnine][Emacs Plugin]]
TabNine is the all-language autocompleter. It uses machine learning to provide responsive, reliable, and relevant suggestions.

** Multiple Cursors
#+begin_src emacs-lisp
(after! mc-mark-more
  (setq! mc/list-file "~/.e/sieman.doom.d/mc-lists.el")
  (setq! mc/match-cursor-style t)
  (define-key mc/keymap (kbd "<return>") nil)
  (message "mc-mark-more loaded")
  )
#+end_src
** Ivy is a generic completion mechanism for Emacs.
#+begin_src emacs-lisp
(after! ivy
  (ido-mode -1)
  ;; (global-unset-key (kbd "s-x"))
  ;; (general-define-key "s-x" 'kill-region)
  )
#+end_src
** Navigate Back and Forward, the Better Jump
Ich mag in einem Buffer herumspringen.
#+begin_src emacs-lisp
(after! better-jumper
  (setq! better-jumper-context 'buffer)
  (setq! better-jumper-use-savehist t)
  (setq! better-jumper-use-evil-jump-advice nil))
#+end_src

** Show Keys
Dies ist ein Minor-Mode und zeigt die gedrückten Tasten an.
#+begin_src emacs-lisp
(load! "+show-keys.el")
#+end_src

** dired - file manager
#+begin_src emacs-lisp
(after! dired
  (add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
  (put 'dired-find-alternate-file 'disabled nil))
#+end_src

** org-mode :org:
#+begin_src emacs-lisp
;; (with-eval-after-load 'org
;; (add-to-list 'sp-ignore-modes-list #'org-mode))
;; (with-eval-after-load 'org-agenda
;; (add-to-list 'sp-ignore-modes-list #'org-agenda-mode))

(after! org

  (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sc" . "src clojure"))
  (add-to-list 'org-structure-template-alist '("ss" . "src shell"))
  (add-to-list 'org-structure-template-alist '("sb" . "src fish :dir ~/ :results output"))
  (add-to-list 'org-structure-template-alist '("sf" . "src fish :mkdirp yes :tangle ~/.terminal-settings/config.fish"))

  (setq org-babel-clojure-backend 'cider
        org-hide-emphasis-markers t)
  )

(add-hook! 'org-log-buffer-setup-hook '(require 'org-keys))

#+end_src

*** Atlassian Export
This litle packages provide a export to jira and confluence  markup.

#+begin_src emacs-lisp :tangle packages.el
(package! ox-jira :recipe (:host github :repo "stig/ox-jira.el"))
(package! ox-confluence-en :recipe (:host github :repo "correl/ox-confluence-en"))
#+end_src
#+begin_src emacs-lisp
(use-package! ox-jira)
(use-package! ox-confluence-en)
#+end_src
*** *Org Face*
#+begin_src emacs-lisp
(add-hook! org-mode
           ;; Document title font
           (set-face-attribute 'org-document-title nil :height 2.0)
           (set-face-attribute 'org-level-1 nil :height 1.1)
           (set-face-attribute 'org-level-2 nil :height 1.1)
           (set-face-attribute 'org-level-3 nil :height 1.1)
           (set-face-attribute 'org-level-4 nil :height 1.1)
           (set-face-attribute 'org-level-5 nil :height 1.1)
           (set-face-attribute 'org-level-6 nil :height 1.1)
           (set-face-attribute 'org-level-7 nil :height 1.1)
           (set-face-attribute 'org-level-8 nil :height 1.1)
           (set-face-attribute 'org-block nil :height 1.1)
           ;; Face of keyword DONE (Green like strings)
           ;; (set-face-attribute 'org-done nil :foreground "#98be65")
           ;; Face of keyword TODO or [ ] (Purple like keywords)
           ;; (set-face-attribute 'org-todo nil :foreground "#c678dd")
           ;; Face of ellipsis symbol (Purple like keywords)
           (set-face-attribute 'org-ellipsis nil :foreground "#c678dd")
           ;; Face of the entire headline of a DONE line
           (set-face-attribute 'org-headline-done nil :foreground nil))
#+end_src
*Babel Support*
Ich möchte gerne Ergebnisse aus Clojures Code mit in org-Dateien einfügen.
[[https://www.orgmode.org/worg/org-contrib/babel/languages/ob-doc-clojure.html][Org-babel support for Clojure]]
** Deft for org-mode

#+begin_src emacs-lisp
(setq deft-extensions '("txt" "tex" "org"))
(setq deft-directory "~/Documents/orgs")
(setq deft-recursive t)
(global-set-key [f8] 'deft)
#+end_src

** Terminals

*** Ansi-Terminal

C-c C-j (term-line-mode) das Terminal verhält sich wie ein Text-Buffer.
C-c C-k (term-char-mode) das Terminal verhält fixirt den Cursor auf den Eingabe-Promt.

C-c C-q (term-pager-toggle)

C-c C-c (term-send-raw)
C-c C-x (term-send-raw)


https://echosa.github.io/blog/2012/06/06/improving-ansi-term/
Wenn man =exit= ins Terminal eingibt beendet sich das Terminal und der Buffer soll sich dabei auch schießen.

#+begin_src emacs-lisp
(defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
  (if (memq (process-status proc) '(signal exit))
      (let ((buffer (process-buffer proc)))
        ad-do-it
        (kill-buffer buffer))
    ad-do-it))
(ad-activate 'term-sentinel)
#+end_src

Ich benutze die Z-Shell und ich möchte auch nicht mehr nach einer anderen Shell gefragt werden.

#+begin_src emacs-lisp
(defvar my-term-shell "/usr/local/bin/fish")
(setq shell-file-name "/usr/local/bin/fish")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
#+end_src

** Cider
*Evaluation:*
_in buffer:_
| =C-x C-e=           | cider-eval-last-sexp |
| =C-c C-e=           |                      |
| =<localleader> e e= |                      |
Evaluate the form preceding point and display the result in the echo area and/or
in an buffer overlay (according to cider-use-overlays). If invoked with a prefix
argument, insert the result into the current buffer.

| =<localleader> p D= | =cider-pprint-eval-defun-to-comment= |
Produces an output like this: =;;-> {"dark olive" 1, "vibrant plum" 2}=

_to REPL:_
| =C-c M-e=           | cider-eval-last-sexp-to-repl        |
| =<localleader> p r= | =cider-pprint-eval-last-sexp-to-repl= |
Evaluate the form preceding point and output it result to the REPL buffer. If
invoked with a prefix argument, takes you to the REPL buffer after being
invoked.

_from Source to REPL:_
| =C-return= | eir-eval-in-cider |
Copy the expression from buffer and paste it in REPL then evaluates it.

Navigation
Refactoring
Editing

Ich möchte gerne eine Historie für die REPL haben.

#+begin_src emacs-lisp
;; (after! cider
(set-popup-rule! "^\\*cider-clojuredocs\\*" :side 'right :size 0.5)
;; )
;; (after! cider-repl-mode
;;   (setq cider-repl-history-size 100000
;;         cider-repl-history-file "~/.organisation/snippedlab/clojure-repl-history"
;;         ))
;; (add-hook! 'cider-mode-hook
;; (setq cider-repl-history-size 10000
;;        cider-repl-history-file "~/.organisation/snippedlab/clojure-repl-history"
;; ))
#+end_src

#+begin_src emacs-lisp
(after! clojure-mode
  (add-hook 'clojure-mode-hook #'aggressive-indent-mode)
  (message "My Clojure config")

  (defun clerk-show ()
    (interactive)
    (save-buffer)
    (let
        ((filename
          (buffer-file-name)))
      (when filename
        (cider-interactive-eval
         (concat "(nextjournal.clerk/show! \"" filename "\")")))))

  (define-key clojure-mode-map (kbd "<M-return>") 'clerk-show)

  )
#+end_src

** Eval in the REPL
#+begin_src emacs-lisp :tangle "packages.el"
(package! eval-in-repl)
#+end_src
#+begin_src emacs-lisp
(after! cider
  (require 'eval-in-repl-cider)
  (define-key clojure-mode-map (kbd "<C-return>") 'eir-eval-in-cider))
#+end_src

** Fly Keys by Xah Lee
#+begin_src emacs-lisp :tangle packages.el
(package! xah-fly-keys :recipe (:host github :repo "xahlee/xah-fly-keys"))
(package! neo-layout-fly-keys :recipe (:host github :repo "sieman/neo-layout-fly-keys"))
#+end_src

#+begin_src emacs-lisp
(after! xah-fly-keys

  (defun sim/flykeys-indicate-command-mode () (interactive)
         (custom-set-faces
          `(cursor ((t (:background "#1ea4ff"))))
          )
         ;; (custom-set-variables '(cursor-type 'hollow))
         (xah-fly-save-buffer-if-file)
         )

  (defun sim/flykeys-indicate-insert-mode () (interactive)
         (custom-set-faces
          `(cursor ((t (:background "red"))))
          )
         (custom-set-variables '(cursor-type 'box))
         (better-jumper-set-jump))

  (add-hook! 'xah-fly-command-mode-activate-hook 'sim/flykeys-indicate-command-mode)
  (add-hook! 'xah-fly-insert-mode-activate-hook  'sim/flykeys-indicate-insert-mode)
  (add-hook! 'magit-mode-hook 'xah-fly-insert-mode-activate)
  (add-hook! 'dired-hook 'xah-fly-insert-mode-activate)
  (add-hook! 'color-rg-mode-hook 'xah-fly-insert-mode-activate)

  (global-set-key (kbd "<f19>") 'xah-fly-command-mode-activate)
  (global-set-key (kbd "ESC ESC") 'xah-fly-command-mode-activate))

(defun sim/flykeys-on ()
  (interactive)
  (neo2/flykeys-on)
  (define-key xah-fly-command-map (kbd "1") nil)
  (define-key xah-fly-command-map (kbd "1") 'delete-other-windows)

  (define-key xah-fly-command-map (kbd "2") nil)
  (define-key xah-fly-command-map (kbd "2") 'split-window-below-and-move-there-dammit)
  (define-key xah-fly-command-map (kbd "3") nil)
  (define-key xah-fly-command-map (kbd "3") 'split-window-right-and-move-there-dammit)
  (define-key xah-fly-command-map (kbd "4") nil)
  (define-key xah-fly-command-map (kbd "4") 'delete-window)

  (define-key xah-fly-command-map (kbd "5") nil)
  (define-key xah-fly-command-map (kbd "5") (kbd! "C-c l"))
  ;;(define-key xah-fly-command-map (kbd "TAB") xah-fly--tab-key-map)

  (define-key xah-fly-command-map (kbd "8") nil)
  (define-key xah-fly-command-map (kbd "8") 'xah-select-text-in-quote)
  (define-key xah-fly-command-map (kbd "9") nil)
  (define-key xah-fly-command-map (kbd "9") 'xah-extend-selection)
  (define-key xah-fly-command-map (kbd "q") nil)
  (define-key xah-fly-command-map (kbd "q") (kbd! "C-c a"))

  (define-key xah-fly-command-map (kbd "o") nil)
  (define-key xah-fly-command-map (kbd "o") (kbd! "C-c"))

  (define-key xah-fly-command-map (kbd "O") nil)
  (define-key xah-fly-command-map (kbd "O") (kbd! "C-x"))

  (define-key xah-fly-command-map (kbd "d") nil)
  (define-key xah-fly-command-map (kbd "d") 'xah-goto-matching-bracket)

  (define-key xah-fly-command-map (kbd ",") nil)
  (define-key xah-fly-command-map (kbd ",") 'open-line)

  ;; (define-key xah-fly-command-map (kbd ".") nil)
  ;; (define-key xah-fly-command-map (kbd ".") xah-fly-dot-keymap)

  (define-key xah-fly-command-map (kbd "j") nil)
  (define-key xah-fly-command-map (kbd "j") 'xah-next-window-or-frame)

  (define-key xah-fly-command-map (kbd "SPC") nil)
  (define-key xah-fly-command-map (kbd "SPC") 'xah-insert-space-before)

  )
#+End_src

** Latex

Change some font weights for the sections in LaTeX
#+begin_src emacs-lisp
(add-hook! LaTeX-mode
  (set-face-attribute 'font-latex-sectioning-1-face nil :height 1.8 :weight 'bold)
  (set-face-attribute 'font-latex-sectioning-2-face nil :height 1.6)
  (set-face-attribute 'font-latex-sectioning-3-face nil :height 1.3)
  (set-face-attribute 'font-latex-sectioning-4-face nil :height 1.1)
  (set-face-attribute 'font-latex-sectioning-5-face nil :height 1.1))
#+end_src

Match the background of latex previews and scale a bit less than the default
#+begin_src emacs-lisp
(after! preview
  (setq preview-scale 1.2)
  (set-face-attribute 'preview-reference-face nil :background (doom-color 'bg)))
#+end_src

** Dict.cc translate
[[https://github.com/martenlienen/dictcc.el][Dictcc]] is a emacs interface for the online dictionary [[https://www.dict.cc/][dict.cc]]. At the moment it use ivy ore helm as completion but not vertico. I use it when vertico is supported.
#+begin_src emacs-lisp :tangle no
(package! dictcc)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! dictcc
  :diminish
  :config
  (setq dictcc-source-lang "en"
        dictcc-destination-lang "de"
        dictcc-completion-backend 'vertico)
  )
#+end_#+begin_src

      #+end_src
* Funktionen
Hier stehen Funktionen, die für die Tastenkürzel verwendet werden.
** Duplicate Line Or Region

#+begin_src emacs-lisp
(defun duplicate-line-or-region (&optional n)
  "Duplicate current line, or region if active.
      With argument N, make N copies.
      With negative N, comment out original line and use the absolute value."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (save-excursion
      (let ((text (if use-region        ;Get region if active, otherwise line
                      (buffer-substring (region-beginning) (region-end))
                    (prog1 (thing-at-point 'line)
                      (end-of-line)
                      (if (< 0 (forward-line 1)) ;Go to beginning of next line, or make a new one
                          (newline))))))
        (dotimes (i (abs (or n 1)))     ;Insert N times, or once if not specified
          (insert text))))
    (if use-region nil                  ;Only if we're working with a line (not a region)
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
        (if (> 0 n)                             ;Comment out original with negative arg
            (comment-region (line-beginning-position) (line-end-position)))
        (forward-line 1)
        (forward-char pos)))))

#+end_src

** Color Themes

#+begin_src emacs-lisp :tangle autoload.el
(defun sim/after-theme-changed ()
  "Custom face settings after theme changed."
  (interactive)
                                        ;(org-bullets-mode nil)
                                        ;(org-bullets-mode t)
                                        ;(set-face-attribute 'mode-line nil :font "JetBrains Mono 12")
  (custom-set-faces
   '(show-paren-match ((t (:background "black" :foreground "yellow" :inverse-video t :weight bold))))
   '(region ((t (:foreground "#f1c40f" :background "#2c3e50" :inverse-video t))))
   `(cursor ((t (:foreground "white" :background "red"))))
   )
  (custom-set-variables '(cursor-type 'box))
  (set-frame-parameter (selected-frame) 'alpha '(100 . 100))
  (message "sim/after-theme-changed done")
  )

(defun sim/disable-all-custom-themes ()
  "Disable all themes and then load a single theme interactively."
  (interactive)
  (while custom-enabled-themes
    (disable-theme (car custom-enabled-themes))))

(defun sim/theme-blue ()
  (interactive)
  (load-theme 'deeper-blue t)
  (set-background-color "#224FBC")
  (set-frame-parameter (selected-frame) 'alpha '(88 . 88)))

(defun sim/elegant-theme ()
  (interactive)
  (sim/disable-all-custom-themes)
  (if doom-modeline-mode
      (doom-modeline-mode))
  ;; (provide 'elegance)
  (if (require 'elegance nil 'noerror)
      (message "elegance is loaded")
    (progn
      (load "./.local/straight/build-27.1/elegant-emacs/sanity.elc")
      (load "./.local/straight/build-27.1/elegant-emacs/elegance.elc"))
    )
  (sim/after-theme-changed)
  )
#+end_src
** Goto Line
- =M-g M-g   = goto line number and shows line numbers
  #+begin_src emacs-lisp :tangle autoload.el
(defun goto-line-with-feedback ()
  "Show line numbers temporarily, while prompting for the line number input"
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (call-interactively 'goto-line))
    (linum-mode -1)))
  #+end_src
** Beschreibe Tastenkürzeltabellen Describe Keymap
Ein nützliches Schnippel zum Beschreiben von einzelnen Keymaps von [[https://stackoverflow.com/questions/3480173/show-keys-in-emacs-keymap-value][stackoverflow]].
#+begin_src emacs-lisp :tangle autoload.el
(defun sim/describe-keymap (keymap)
  "Describe a keymap using `substitute-command-keys'."
  (interactive
   (list (completing-read
          "Keymap: " (let (maps)
                       (mapatoms (lambda (sym)
                                   (and (boundp sym)
                                        (keymapp (symbol-value sym))
                                        (push sym maps))))
                       maps)
          nil t)))
  (with-output-to-temp-buffer (format "*keymap: %s*" keymap)
    (princ (format "%s\n\n" keymap))
    (princ (substitute-command-keys (format "\\{%s}" keymap)))
    (with-current-buffer standard-output ;; temp buffer
      (setq help-xref-stack-item (list #'my-describe-keymap keymap)))))
#+end_src

** (de)activate Alt Modifier
#+begin_src emacs-lisp :tangle autoload.el
(defun sim/disable-alt-modifier ()
  (interactive)
  (setq mac-option-modifier 'none
        mac-right-option-modifier 'none)
  (message "Modifier Option set to none"))

(defun sim/enable-alt-modifier ()
  (interactive)
  (setq mac-option-modifier 'alt
        mac-right-option-modifier 'alt)
  (message "Modifier Option set to alt"))
#+end_src

** smartparens
#+begin_src emacs-lisp :tangle autoload.el
(defun sim/disable-smartparens ()
  "Disable smartparens mode globaly."
  (interactive)
  (turn-off-smartparens-mode)
  (turn-off-smartparens-strict-mode)
  (smartparens-global-mode -1)
  )
#+end_src

** Org Edit Speacial block
#+begin_src emacs-lisp :tangle autoload.el
(defun sim/org-edit-special ()
  "Edits org special blocks and maximize that buffer."
  (interactive)
  (org-edit-special)
  (delete-other-windows))

(defun sim/org-edit-src-exit ()
  "Exits org special src buffer."
  (interactive)
  (org-edit-src-exit)
  (delete-other-windows))
#+end_src

* Keybinding
#+begin_src emacs-lisp
;; (defadvice split-window (after move-point-to-new-window activate)
;; "Moves the point to the newly created window after splitting."
;; (other-window 1))

;; from https://gist.github.com/3402786
(defun sim/toggle-maximize-buffer ()
  "Maximize buffer"
  (interactive)
  (save-excursion
    (if (and (= 1 (length (window-list)))
             (assoc ?_ register-alist))
        (jump-to-register ?_)
      (progn
        (window-configuration-to-register ?_)
        (delete-other-windows)))))


(defun split-window-right-and-move-there-dammit ()
  (interactive)
  (split-window-right)
  (windmove-right))

(global-set-key (kbd "C-x 3") 'split-window-right-and-move-there-dammit)

(defun split-window-below-and-move-there-dammit ()
  (interactive)
  (split-window-below)
  (windmove-down))

(global-set-key (kbd "C-x 2") 'split-window-below-and-move-there-dammit)

(global-unset-key (kbd "s-x"))
(global-unset-key (kbd "s-C"))
(global-unset-key (kbd "s-w"))
(global-unset-key (kbd "s-k"))
(global-unset-key (kbd "s-e"))
(global-unset-key (kbd "s-o"))
(global-unset-key (kbd "s-d"))
(global-unset-key (kbd "A-<tab>"))
(global-unset-key (kbd "C-@"))
(global-unset-key (kbd "M-SPC"))
(global-unset-key (kbd "M-@"))
(global-unset-key (kbd "s-n"))
(global-set-key [remap goto-line] 'goto-line-with-feedback)

(after! term
  (general-def term-raw-map
    "s-v" 'term-paste))

;; (map! :prefix "C-c o"
;;       :desc "open a ansi Terminal" "t" #'ansi-term)


;; (map! :after ivy :map ivy-mode-map :prefix "s-O"
;;       :desc "recent files" "r" #'counsel-recentf
;;       :desc "open file" "f" #'counsel-find-file
;;       "p" #'ns-open-file-using-panel
;;       )

(general-def org-mode-map
  :prefix "s-O"
  "o" 'org-open-at-point
  "s" 'sim/org-edit-special
  "e" 'org-babel-execute-src-block
  "t" 'org-babel-tangle
  )

(general-def org-src-mode-map
  "s-w" 'sim/org-edit-src-exit)


(general-define-key
 :keymaps 'org-mode-map
 "s-o" 'consult-org-heading
                                        ;'counsel-org-goto
 "s-b" 'org-emphasize
 "s-<return>" 'org-meta-return
 )

(general-def cider-repl-mode-map
  "s-o" 'cider-repl-history
  "s-s" 'cider-repl-history-save
  )


(map!

 "H-<mouse-1>" #'mc/add-cursor-on-click
 ;;"" #'mc/add-cursors-to-all-matches
 "H-l" #'mc/edit-lines
 "H-w" #'mc/mark-all-words-like-this
 "H-h" #'mc/mark-previous-symbol-like-this
 "H-g" #'mc/mark-previous-word-like-this
 "H-f" #'mc/mark-next-symbol-like-this

 "H-s" #'mc/edit-beginnings-of-lines
 "H-n" #'mc/mark-previous-like-this
 "H-N" #'mc/unmark-previous-like-this ; doom default
 "H-r" #'mc/mark-next-word-like-this
 "H-t" #'mc/mark-next-like-this
 "H-T" #'mc/unmark-next-like-this ; doom default
 "H-d" #'mc/mark-all-like-this-in-defun ; doom default
 "H-y" #'mc/edit-ends-of-lines

 "H-b" #'mc/mark-all-symbols-like-this
 "H-m" #'mc/mark-all-dwim
 "H-M" #'mc/mark-all-like-this-dwim ; doom default
 "H-," #'mc/mark-all-in-region
 "H-e" #'mc/mark-more-like-this-extended

 "H-z" #'mc/reverse-regions
 "H-a" #'mc/sort-regions
 :prefix "H-0"
 "n" #'mc/insert-numbers
 "l" #'mc/insert-letters
 )

(map!
 ;; Buffer-local font scaling
 "s-+" #'doom/reset-font-size
 ;; "s-=" #'doom/increase-font-size
 "s--" #'doom/decrease-font-size
 ;; Conventional text-editing keys & motions
 "s-/" (cmd! (save-excursion (comment-line 1)))

 ;; f1
 ;; f2
 ;; f3
 ;; f4
 "<f5>" #'next-error
 ;; f6
 ;; f7
 ;; f8
 ;; f9
 "S-<f10>" #'highlight-symbol-at-point
 "C-<f10>" #'highlight-phrase
 "<f11>" #'sim/toggle-maximize-buffer
 "s-<f11>" #'toggle-frame-fullscreen
 "C-<f12>" #'imenu

 "s-1" #'+treemacs/toggle
 ;; 2
 ;; 3
 ;; 4
 ;; 5
 ;; 6
 ;; 7
 ;; 8
 "s-9" #'magit-status
 ;; 0

 ;; x
 "s-x" #'kill-region
 "s-v" #'yank
 "s-V" #'yank-pop
 ;; l
 "s-l" (if (featurep 'vertico) #'consult-goto-line #'goto-line)
 "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill)
 "s-C" #'comment-line
 "M-s-c" #'comment-or-uncomment-region
 "s-w" #'kill-current-buffer
 "s-W" #'delete-frame
 "C-c w t" #'sim/toggle-maximize-buffer
 ;; k
 :desc "Mark previous" "A-s-h" #'mc/mark-previous-like-this
 :desc "Mark previous" "s-<" #'mc/mark-previous-like-this
 :desc "Mark next" "s->" #'mc/mark-next-like-this
 :desc "Mark next" "A-s-g" #'mc/mark-next-like-this
 :desc "Unmark previous" "A-C-h" #'mc/unmark-previous-like-this
 :desc "Unmark previous" "C-<" #'mc/unmark-previous-like-this
 :desc "Unmark next" "C->" #'mc/unmark-next-like-this
 :desc "Unmark next" "A-C-g" #'mc/unmark-next-like-this
 "s-G" #'isearch-repeat-backward
 "s-f" #'consult-line
 ;; q
 "s-q" (if (daemonp) #'delete-frame #'save-buffers-kill-terminal)
 ;; ß

 ;; u
 :desc "Reformat Source Code" "s-i" #'indent-region
 "s-a" #'mark-whole-buffer
 "s-A" #'execute-extended-command
 "s-e" #'ido-switch-buffer
 ;; o
 ;; s
 "s-s" #'save-buffer
 ;; n
 "s-n" #'+default/new-buffer
 "s-N" #'make-frame
 ;; r
 ;; t
 "C-x C-A-t" #'text-scale-decrease
 ;; d
 "s-d" #'duplicate-line-or-region
 "s-y" #'other-frame  ; fix frame-switching

 ;; ü
 ;; ö
 ;; ä
 "s-ä" #'avy-goto-char-2
 "s-Ä c" #'avy-goto-char
 "s-Ä l" #'avy-goto-line
 "s-Ä w" #'avy-goto-word-1
 "s-Ä o" #'avy-org-goto-heading-timer
 ;; p
 ;; z
 "s-z" #'undo
 "s-Z" #'redo
 ;; b
 "C-x C-b" #'ibuffer
 "C-x b" #'ido-switch-buffer
 "C-x C-A-b" #'text-scale-increase
 ;; m
 ;; ,
 ;; .
 :desc "Jumps to next error" "C-•" #'next-error
 ;; j
 "C-S-j" #'join-line
 "s-J" #'join-line

 "s-<up>" #'consult-global-mark
 "s-<down>" #'consult-mark
 "s-<f1>" #'better-jumper-jump-newest
 "s-<left>" #'doom/backward-to-bol-or-indent
 "s-<right>" #'doom/forward-to-last-non-comment-or-eol

 "C-s-<up>" #'windmove-up
 "C-s-<down>" #'windmove-down
 "C-s-<left>" #'windmove-left
 "C-s-<right>" #'windmove-right

 "s-S-<up>"  #'drag-stuff-up
 "s-S-<down>"  #'drag-stuff-down
 "s-S-<left>"  #'drag-stuff-left
 "s-S-<right>"  #'drag-stuff-right

 "A-<up>"  #'er/expand-region
 "A-<down>" #'er/contract-region
 "A-<left>" #'left-word
 "A-<right>" #'right-word

 "S-s-SPC a" #'mc/mark-all-like-this
 "S-s-SPC l" #'mc/edit-lines
 :desc "Mark Paragraph"   "S-s-SPC p" #'mark-paragraph
 :desc "Mark Symbol"   "S-s-SPC s" #'er/mark-symbol
 :desc "Mark Prefix S."   "S-s-SPC S" #'er/mark-symbol-with-prefix
 :desc "Mark Word"   "S-s-SPC w" #'er/mark-word
 :desc "Mark Function"   "S-s-SPC f" #'er/mark-defun
 :desc "Mark Comment"   "S-s-SPC c" #'er/mark-comment
 :desc "Mark URL"   "S-s-SPC u" #'er/mark-url
 :desc "Mark ins Pairs"   "S-s-SPC i" #'er/mark-inside-pairs
 :desc "Mark ins Quotes"   "S-s-SPC I" #'er/mark-inside-quotes
 :desc "Mark out Pairs"   "S-s-SPC o" #'er/mark-outside-pairs
 :desc "Mark out Quotes"   "S-s-SPC O" #'er/mark-outside-quotes
 :desc "Mark Email"   "S-s-SPC e" #'er/mark-email
 )
(sim/flykeys-on)
#+end_src


* Neues
Farbige Ausgabe von Tastenkürzel. https://www.youtube.com/watch?v=QfN0gNaxE2U Show your Emacs shortcuts in colour when giving presentations

https://github.com/michael-heerdegen/interaction-log.el

eval in rple just ctr enter https://github.com/kaz-yos/eval-in-repl
iMenu javascript https://emacs.stackexchange.com/questions/2658/how-to-display-the-list-of-functions-in-imenu-and-collapse-uncollapse-functions
* Fehlerbehbungen
** Dired Dateinamen kopieren mit Zeilenumbruch
Dieser Fix fügt statt eines Leerzeichens einen Zeilenumbruch ein.

#+begin_src emacs-lisp
(defun dired-copy-filename-as-kill (&optional arg)
  "Copy names of marked (or next ARG) files into the kill ring.
The names are separated by a space.
With a zero prefix arg, use the absolute file name of each marked file.
With \\[universal-argument], use the file name relative to the Dired buffer's
`default-directory'.  (This still may contain slashes if in a subdirectory.)

If on a subdir headerline, use absolute subdirname instead;
prefix arg and marked files are ignored in this case.

You can then feed the file name(s) to other commands with \\[yank]."
  (interactive "P")
  (let ((string
         (or (dired-get-subdir)
             (mapconcat #'identity
                        (if arg
                            (cond ((zerop (prefix-numeric-value arg))
                                   (dired-get-marked-files))
                                  ((consp arg)
                                   (dired-get-marked-files t))
                                  (t
                                   (dired-get-marked-files
				    'no-dir (prefix-numeric-value arg))))
                          (dired-get-marked-files 'no-dir))
                        "\n"))))
    (unless (string= string "")
      (if (eq last-command 'kill-region)
          (kill-append string nil)
        (kill-new string))
      (message "%s" string))))
#+end_src
