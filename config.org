#+TITLE: Einstellungen Configuration
* package.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments link
:END:
Package loading
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
#+end_src

#+begin_src emacs-lisp
;; (package! rg) ; not using it at the moment
(package! xah-fly-keys)
(package! four-modifier :recipe (:host github :repo "sieman/four-modifier"))
(package! neo-layout-fly-keys :recipe (:host github :repo "sieman/neo-layout-fly-keys"))
;; https://github.com/rougier/elegant-emacs (package! elegant-emacs :recipe (:host github :repo "rougier/elegant-emacs"))
;;(package! meow)                         ; is a modal keybinding system like xah-fly-keys and evil
(package! aggressive-indent-mode)

#+end_src

* Einstellungen :settings:
** Darstellung :appearance:

#224FBC Blauer Hintergrund wie Ocean

#+begin_src emacs-lisp
(display-time-mode t)
(setq display-time-24hr-format t)
(setq display-line-numbers-type nil)
(setq mixed-pitch-variable-pitch-cursor nil)
(load! "sim-calendar")
(load! "~/.emacs.secrets")
(setq fill-column sim-hard-wrap-at)
;; Theme related things
(load! "+themes")

;; Select and raise the frame, always
(select-frame-set-input-focus (selected-frame))

;; Hide the menu for as minimalistic a startup screen as possible.
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
#+end_src
*** Prety Symbol Mode Disable
https://github.com/hlissner/doom-emacs/issues/1807

#+begin_src emacs-lisp
                                        ;(setq +pretty-code-enabled-modes nil)
;; or
                                        ;(remove-hook 'after-change-major-mode-hook #'+pretty-code-init-pretty-symbols-h)
;; (setq! +ligatures-composition-alist nil)
#+end_src
*** Which Key Mode
#+begin_src emacs-lisp
(after! which-key
  (setq which-key-side-window-max-width 0.44
        which-key-max-display-columns 2
        which-key-side-window-max-height 0.26
        which-key-max-description-length 90)
  (which-key-setup-side-window-right-bottom))
#+end_src
*** Modeline
#+begin_src emacs-lisp
(after! doom-modeline
  (require 'doom-modeline)
  (setq doom-modeline-modal-icon nil)
  ;; https://github.com/hlissner/doom-emacs/issues/2967
  (setq all-the-icons-scale-factor 1.1) ;; orignal val 1.2

  (custom-set-faces!
    '(mode-line :family "Iosevka SS04" :height 0.96)
    '(mode-line-inactive :family "Iosevka SS04" :height 0.96))

  (message "doom-modeline is loaded. :-)"))
#+end_src
*** Fonts
;; "JetBrains Mono"
;; "LFBONovelNetz" "LOB.Novellenschrift" "LOV.Novellenschrift" "LUC.NovellenschriftU1A"
;; "Iosevka" "Iosevka Fixed" "Iosevka Term" "Iosevka SS04"
;; "Source Code Variable"
;; "Overpass Nerd Font"
;; https://github.com/Lindydancer/font-lock-studio debugging font

#+begin_src emacs-lisp
;; (print (font-family-list))

(setq doom-font (font-spec :family "Iosevka SS04" :style "Thin" :size 13)
      doom-variable-pitch-font (font-spec :family "LOV.Novellenschrift" :size 20)
      ;; ivy-posframe-font (font-spec :family "Iosevka SS04" :style "Thin" :size 12 )
      doom-big-font (font-spec :family "Iosevka SS04" :style "Bold" :size 20))

(after! doom-themes
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t))

(custom-set-faces!
  '(font-lock-comment-face :slant italic)
  '(font-lock-keyword-face :slant italic))
#+end_src

** Editor Erweiterungen :editor:
*** Rechtschreibprüfung :spell:checking:

npm install dictionary-en-gb

#+begin_src emacs-lisp
(setq ispell-dictionary "de_DE")
(setq ispell-hunspell-dict-paths-alist
      '(
        ("de_DE" "~/Library/Spelling/de_DE.aff")
        ("en_GB" "~/Library/Spelling/en_GB.aff")
        ))
#+end_src
*** Tastaturlayout :keyboard:layout:
#+begin_src emacs-lisp
(require 'four-modifier)
(load! "+neo-layout.el")
#+end_src

*** Multiple Cursors
#+begin_src emacs-lisp
(after! mc-mark-more
  (setq! mc/list-file "~/.e/sieman.doom.d/mc-lists.el")
  (setq! mc/match-cursor-style t)
  (define-key mc/keymap (kbd "<return>") nil)
  (message "mc-mark-more loaded")
  )
#+end_src
*** Ivy is a generic completion mechanism for Emacs.
#+begin_src emacs-lisp
(after! ivy
  (ido-mode -1)
  ;; (global-unset-key (kbd "s-x"))
  ;; (general-define-key "s-x" 'kill-region)
  )
#+end_src
*** Navigate Back and Forward, the Better Jump
Ich mag in einem Buffer herumspringen.
#+begin_src emacs-lisp
(after! better-jumper
  (setq! better-jumper-context 'buffer)
  (setq! better-jumper-use-savehist t)
  (setq! better-jumper-use-evil-jump-advice nil))
#+end_src

*** Show Keys
Dies ist ein Minor-Mode und zeigt die gedrückten Tasten an.
#+begin_src emacs-lisp
(load! "+show-keys.el")
#+end_src

** Modus Anwendungen :settings:modes:
*** dired - file manager
#+begin_src emacs-lisp
(after! dired
  (add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
  (put 'dired-find-alternate-file 'disabled nil))
#+end_src

*** org-mode :org:
#+begin_src emacs-lisp
;; (with-eval-after-load 'org
;; (add-to-list 'sp-ignore-modes-list #'org-mode))
;; (with-eval-after-load 'org-agenda
;; (add-to-list 'sp-ignore-modes-list #'org-agenda-mode))

(after! org
  (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sc" . "src clojure"))
  (add-to-list 'org-structure-template-alist '("ss" . "src shell"))

  (setq org-use-speed-commands t
        org-babel-clojure-backend 'cider
        org-hide-emphasis-markers t))

(add-hook! 'org-log-buffer-setup-hook '(require 'org-keys))

#+end_src

*Jira Export*
This litle packages provide a export to jira markup.

#+begin_src emacs-lisp :tangle packages.el
(package! ox-jira :recipe (:host github :repo "stig/ox-jira.el"))
#+end_src
#+begin_src emacs-lisp
(use-package! ox-jira)
#+end_src

*Babel Support*
Ich möchte gerne Ergebnisse aus Clojures Code mit in org-Dateien einfügen.
[[https://www.orgmode.org/worg/org-contrib/babel/languages/ob-doc-clojure.html][Org-babel support for Clojure]]
*** Deft for org-mode

#+begin_src emacs-lisp
(setq deft-extensions '("txt" "tex" "org"))
(setq deft-directory "~/Documents/orgs")
(setq deft-recursive t)
(global-set-key [f8] 'deft)
#+end_src

*** Terminals

**** Ansi-Terminal

C-c C-j (term-line-mode) das Terminal verhält sich wie ein Text-Buffer.
C-c C-k (term-char-mode) das Terminal verhält fixirt den Cursor auf den Eingabe-Promt.

C-c C-q (term-pager-toggle)

C-c C-c (term-send-raw)
C-c C-x (term-send-raw)


https://echosa.github.io/blog/2012/06/06/improving-ansi-term/
Wenn man =exit= ins Terminal eingibt beendet sich das Terminal und der Buffer soll sich dabei auch schießen.

#+begin_src emacs-lisp
(defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
  (if (memq (process-status proc) '(signal exit))
      (let ((buffer (process-buffer proc)))
        ad-do-it
        (kill-buffer buffer))
    ad-do-it))
(ad-activate 'term-sentinel)
#+end_src

Ich benutze die Z-Shell und ich möchte auch nicht mehr nach einer anderen Shell gefragt werden.

#+begin_src emacs-lisp
(defvar my-term-shell "/bin/zsh")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
#+end_src

*** Cider Clojure Enviroment
Ich möchte gerne eine Historie für die REPL haben.

#+begin_src emacs-lisp
;; (after! cider
(set-popup-rule! "^\\*cider-clojuredocs\\*" :side 'right :size 0.5)
;; )
;; (after! cider-repl-mode
;;   (setq cider-repl-history-size 100000
;;         cider-repl-history-file "~/.organisation/snippedlab/clojure-repl-history"
;;         ))
;; (add-hook! 'cider-mode-hook
;; (setq cider-repl-history-size 10000
;;        cider-repl-history-file "~/.organisation/snippedlab/clojure-repl-history"
;; ))
#+end_src

#+begin_src emacs-lisp
(after! clojure-mode
  (add-hook 'clojure-mode-hook #'aggressive-indent-mode)
  (message "My Clojure config"))
#+end_src

*** Fly Keys by Xah Lee
#+begin_src emacs-lisp
(after! xah-fly-keys

  (defun sim/flykeys-indicate-command-mode () (interactive)
         (custom-set-faces
          `(cursor ((t (:background "#d87a00"))))
          )
         (custom-set-variables '(cursor-type 'hollow))
         (xah-fly-save-buffer-if-file)
         )

  (defun sim/flykeys-indicate-insert-mode () (interactive)
         (custom-set-faces
          `(cursor ((t (:background "red"))))
          )
         (custom-set-variables '(cursor-type 'box)))

  (add-hook! 'xah-fly-command-mode-activate-hook 'sim/flykeys-indicate-command-mode)
  (add-hook! 'xah-fly-insert-mode-activate-hook  'sim/flykeys-indicate-insert-mode)
  (add-hook! 'magit-mode-hook 'xah-fly-insert-mode-activate)
  (add-hook! 'dired-hook 'xah-fly-insert-mode-activate)
  (add-hook! 'color-rg-mode-hook 'xah-fly-insert-mode-activate)

  (global-set-key (kbd "<f19>") 'xah-fly-command-mode-activate)
  (global-set-key (kbd "ESC ESC") 'xah-fly-command-mode-activate))

(defun sim/flykeys-on ()
  (interactive)
  (neo2/flykeys-on)
  (define-key xah-fly-command-map (kbd "SPC") nil)
  (define-key xah-fly-command-map (kbd "SPC") (kbd! "C-c")))
#+End_src

*** Beacon
#+begin_src emacs-lisp :tangle "packages.el" :comments no
(package! beacon)
#+end_src

#+begin_src emacs-lisp
(use-package! beacon
  :diminish
  :config
  (setq beacon-color "#9a37ff")
  (beacon-mode t)
  )
#+end_src

* Funktionen
Hier stehen Funktionen, die für die Tastenkürzel verwendet werden.
*** Ist das Packet das, das ich gebrauche?
(if (require 'tee nil 'noerror)
(message "Ja ist installiert")
(message "Nein ist nicht installiert"))

#+begin_src emacs-lisp
(defun nk/check-package (name fct)
  "Is package installed then executes fct otherwise give a message."
  (interactive)

  (if (require  name nil 'noerror)
      (funcall-interactively fct)
    (message (concat "neo-keybinding missing package: " (symbol-name name)))))
#+end_src

*** Duplicate Line Or Region

#+begin_src emacs-lisp
(defun duplicate-line-or-region (&optional n)
  "Duplicate current line, or region if active.
      With argument N, make N copies.
      With negative N, comment out original line and use the absolute value."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (save-excursion
      (let ((text (if use-region        ;Get region if active, otherwise line
                      (buffer-substring (region-beginning) (region-end))
                    (prog1 (thing-at-point 'line)
                      (end-of-line)
                      (if (< 0 (forward-line 1)) ;Go to beginning of next line, or make a new one
                          (newline))))))
        (dotimes (i (abs (or n 1)))     ;Insert N times, or once if not specified
          (insert text))))
    (if use-region nil                  ;Only if we're working with a line (not a region)
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
        (if (> 0 n)                             ;Comment out original with negative arg
            (comment-region (line-beginning-position) (line-end-position)))
        (forward-line 1)
        (forward-char pos)))))

#+end_src

*** Color Themes

#+begin_src emacs-lisp :tangle autoload.el
(defun sim/after-theme-changed ()
  "Custom face settings after theme changed."
  (interactive)
                                        ;(org-bullets-mode nil)
                                        ;(org-bullets-mode t)
                                        ;(set-face-attribute 'mode-line nil :font "JetBrains Mono 12")
  (custom-set-faces
   '(show-paren-match ((t (:background "black" :foreground "yellow" :inverse-video t :weight bold))))
   '(region ((t (:foreground "#f1c40f" :background "#2c3e50" :inverse-video t))))
   `(cursor ((t (:foreground "white" :background "red"))))
   )
  (custom-set-variables '(cursor-type 'box))
  (set-frame-parameter (selected-frame) 'alpha '(100 . 100))
  (message "sim/after-theme-changed done")
  )

(defun sim/disable-all-custom-themes ()
  "Disable all themes and then load a single theme interactively."
  (interactive)
  (while custom-enabled-themes
    (disable-theme (car custom-enabled-themes))))

(defun sim/theme-blue ()
  (interactive)
  (load-theme 'deeper-blue t)
  (set-background-color "#224FBC")
  (set-frame-parameter (selected-frame) 'alpha '(88 . 88)))

(defun sim/elegant-theme ()
  (interactive)
  (sim/disable-all-custom-themes)
  (if doom-modeline-mode
      (doom-modeline-mode))
  ;; (provide 'elegance)
  (if (require 'elegance nil 'noerror)
      (message "elegance is loaded")
    (progn
      (load "./.local/straight/build-27.1/elegant-emacs/sanity.elc")
      (load "./.local/straight/build-27.1/elegant-emacs/elegance.elc"))
    )
  (sim/after-theme-changed)
  )
#+end_src
*** Goto Line
- =M-g M-g   = goto line number and shows line numbers
  #+begin_src emacs-lisp :tangle autoload.el
(defun goto-line-with-feedback ()
  "Show line numbers temporarily, while prompting for the line number input"
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (call-interactively 'goto-line))
    (linum-mode -1)))
  #+end_src
*** Beschreibe Tastenkürzeltabellen Describe Keymap
Ein nützliches Schnippel zum Beschreiben von einzelnen Keymaps von [[https://stackoverflow.com/questions/3480173/show-keys-in-emacs-keymap-value][stackoverflow]].
#+begin_src emacs-lisp :tangle autoload.el
(defun sim/describe-keymap (keymap)
  "Describe a keymap using `substitute-command-keys'."
  (interactive
   (list (completing-read
          "Keymap: " (let (maps)
                       (mapatoms (lambda (sym)
                                   (and (boundp sym)
                                        (keymapp (symbol-value sym))
                                        (push sym maps))))
                       maps)
          nil t)))
  (with-output-to-temp-buffer (format "*keymap: %s*" keymap)
    (princ (format "%s\n\n" keymap))
    (princ (substitute-command-keys (format "\\{%s}" keymap)))
    (with-current-buffer standard-output ;; temp buffer
      (setq help-xref-stack-item (list #'my-describe-keymap keymap)))))
#+end_src

*** (de)activate Alt Modifier
#+begin_src emacs-lisp :tangle autoload.el
(defun sim/disable-alt-modifier ()
  (interactive)
  (setq mac-option-modifier 'none
        mac-right-option-modifier 'none)
  (message "Modifier Option set to none"))

(defun sim/enable-alt-modifier ()
  (interactive)
  (setq mac-option-modifier 'alt
        mac-right-option-modifier 'alt)
  (message "Modifier Option set to alt"))
#+end_src

*** smartparens
#+begin_src emacs-lisp :tangle autoload.el
(defun sim/disable-smartparens ()
  "Disable smartparens mode globaly."
  (interactive)
  (turn-off-smartparens-mode)
  (turn-off-smartparens-strict-mode)
  (smartparens-global-mode -1)
  )
#+end_src
* Keybinding
#+begin_src emacs-lisp
;; (defadvice split-window (after move-point-to-new-window activate)
;; "Moves the point to the newly created window after splitting."
;; (other-window 1))

(defun split-window-right-and-move-there-dammit ()
  (interactive)
  (split-window-right)
  (windmove-right))

(global-set-key (kbd "C-x 3") 'split-window-right-and-move-there-dammit)

(defun split-window-below-and-move-there-dammit ()
  (interactive)
  (split-window-below)
  (windmove-down))

(global-set-key (kbd "C-x 2") 'split-window-below-and-move-there-dammit)

(global-unset-key (kbd "s-x"))
(global-unset-key (kbd "s-C"))
;; (global-unset-key (kbd "s-w"))
(global-unset-key (kbd "s-k"))
(global-unset-key (kbd "s-e"))
(global-unset-key (kbd "s-o"))
(global-unset-key (kbd "s-d"))
(global-unset-key (kbd "A-<tab>"))
(global-unset-key (kbd "C-@"))
(global-unset-key (kbd "M-SPC"))
(global-unset-key (kbd "M-@"))
(global-unset-key (kbd "s-n"))
(global-set-key [remap goto-line] 'goto-line-with-feedback)

(after! term
  (general-def term-raw-map
    "s-v" 'term-paste))

(map! :prefix "C-c o"
      :desc "open a ansi Terminal" "t" #'ansi-term)


(map! :after ivy :map ivy-mode-map :prefix "s-O"
      :desc "recent files" "r" #'counsel-recentf
      :desc "open file" "f" #'counsel-find-file
      "p" #'ns-open-file-using-panel
      )

(general-def org-mode-map
  :prefix "s-O"
  "o" 'org-open-at-point
  "s" 'sim/org-edit-special
  "e" 'org-babel-execute-src-block
  "t" 'org-babel-tangle
)

(general-def org-src-mode-map
  "s-w" 'sim/org-edit-src-exit)


(general-define-key
 :keymaps 'org-mode-map
 "s-o" 'counsel-org-goto
 "s-b" 'org-emphasize
 "s-<return>" 'org-meta-return
 )

(general-def cider-repl-mode-map
  "s-o" 'cider-repl-history
  "s-s" 'cider-repl-history-save
  )


(map!

 "H-<mouse-1>" #'mc/add-cursor-on-click
 ;;"" #'mc/add-cursors-to-all-matches
 "H-l" #'mc/edit-lines
 "H-w" #'mc/mark-all-words-like-this
 "H-h" #'mc/mark-previous-symbol-like-this
 "H-g" #'mc/mark-previous-word-like-this
 "H-f" #'mc/mark-next-symbol-like-this

 "H-s" #'mc/edit-beginnings-of-lines
 "H-n" #'mc/mark-previous-like-this
 "H-N" #'mc/unmark-previous-like-this ; doom default
 "H-r" #'mc/mark-next-word-like-this
 "H-t" #'mc/mark-next-like-this
 "H-T" #'mc/unmark-next-like-this ; doom default
 "H-d" #'mc/mark-all-like-this-in-defun ; doom default
 "H-y" #'mc/edit-ends-of-lines

 "H-b" #'mc/mark-all-symbols-like-this
 "H-m" #'mc/mark-all-dwim
 "H-M" #'mc/mark-all-like-this-dwim ; doom default
 "H-," #'mc/mark-all-in-region
 "H-e" #'mc/mark-more-like-this-extended

 "H-z" #'mc/reverse-regions
 "H-a" #'mc/sort-regions
 :prefix "H-0"
 "n" #'mc/insert-numbers
 "l" #'mc/insert-letters
 )


(nk/check-package 'flyspell-correct
                  (lambda () (general-define-key "C-M-," 'flyspell-correct-wrapper)))

(map!
 ;; Buffer-local font scaling
 "s-+" #'doom/reset-font-size
 ;; "s-=" #'doom/increase-font-size
 "s--" #'doom/decrease-font-size
 ;; Conventional text-editing keys & motions
 "s-/" (cmd! (save-excursion (comment-line 1)))

 ;; f1
 ;; f2
 ;; f3
 ;; f4
 "<f5>" #'next-error
 ;; f6
 ;; f7
 ;; f8
 ;; f9
 "S-<f10>" #'highlight-symbol-at-point
 "C-<f10>" #'highlight-phrase
 "C-<f11>" #'sim/disable-alt-modifier
 "s-<f11>" #'sim/enable-alt-modifier
 "C-<f12>" #'imenu

 "s-1" #'+treemacs/toggle
 ;; 2
 ;; 3
 ;; 4
 ;; 5
 ;; 6
 ;; 7
 ;; 8
 "s-9" #'magit-status
 ;; 0

 ;; x
 "  s-x" #'kill-region
 "s-v" #'yank
 "s-V" #'counsel-yank-pop
 ;; l
 "s-l" #'goto-line
 "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill)
 "s-C" #'comment-line
 "M-s-c" #'comment-or-uncomment-region
 ;; "s-w" #'kill-current-buffer
 "s-W" #'delete-frame
 ;; k
 :desc "Mark previous" "A-s-h" #'mc/mark-previous-like-this
 :desc "Mark previous" "s-<" #'mc/mark-previous-like-this
 :desc "Mark next" "s->" #'mc/mark-next-like-this
 :desc "Mark next" "A-s-g" #'mc/mark-next-like-this
 :desc "Unmark previous" "A-C-h" #'mc/unmark-previous-like-this
 :desc "Unmark previous" "C-<" #'mc/unmark-previous-like-this
 :desc "Unmark next" "C->" #'mc/unmark-next-like-this
 :desc "Unmark next" "A-C-g" #'mc/unmark-next-like-this
 "s-G" #'isearch-repeat-backward
 "s-f" #'consult-line
 ;; q
 "s-q" (if (daemonp) #'delete-frame #'save-buffers-kill-terminal)
 ;; ß

 ;; u
 :desc "Reformat Source Code" "s-i" #'indent-region
 "s-a" #'mark-whole-buffer
 "s-A" #'execute-extended-command
 "s-e" #'ido-switch-buffer
 ;; o
 ;; s
 "s-s" #'save-buffer
 ;; n
 "s-n" #'+default/new-buffer
 "s-N" #'make-frame
 ;; r
 ;; t
 "C-x C-A-t" #'text-scale-decrease
 ;; d
 "s-d" #'duplicate-line-or-region
 "s-y" #'other-frame  ; fix frame-switching

 ;; ü
 ;; ö
 ;; ä
 "s-ä" #'avy-goto-char-2
 "s-Ä c" #'avy-goto-char
 "s-Ä l" #'avy-goto-line
 "s-Ä w" #'avy-goto-word-1
 "s-Ä o" #'avy-org-goto-heading-timer
 ;; p
 ;; z
 "s-z" #'undo
 "s-Z" #'redo
 ;; b
 "C-x C-b" #'ibuffer
 "C-x b" #'ido-switch-buffer
 "C-x C-A-b" #'text-scale-increase
 ;; m
 ;; ,
 ;; .
 :desc "Jumps to next error" "C-•" #'next-error
 ;; j
 "C-S-j" #'join-line
 "s-J" #'join-line

 "s-<up>" #'better-jumper-jump-backward
 "s-<down>" #'better-jumper-jump-forward
 "s-<left>" #'doom/backward-to-bol-or-indent
 "s-<right>" #'doom/forward-to-last-non-comment-or-eol

 "C-s-<up>" #'windmove-up
 "C-s-<down>" #'windmove-down
 "C-s-<left>" #'windmove-left
 "C-s-<right>" #'windmove-right

 "s-S-<up>"  #'drag-stuff-up
 "s-S-<down>"  #'drag-stuff-down
 "s-S-<left>"  #'drag-stuff-left
 "s-S-<right>"  #'drag-stuff-right

 "A-<up>"  #'er/expand-region
 "A-<down>" #'er/contract-region
 "A-<left>" #'left-word
 "A-<right>" #'right-word

 "S-s-SPC a" #'mc/mark-all-like-this
 "S-s-SPC l" #'mc/edit-lines
 :desc "Mark Paragraph"   "S-s-SPC p" #'mark-paragraph
 :desc "Mark Symbol"   "S-s-SPC s" #'er/mark-symbol
 :desc "Mark Prefix S."   "S-s-SPC S" #'er/mark-symbol-with-prefix
 :desc "Mark Word"   "S-s-SPC w" #'er/mark-word
 :desc "Mark Function"   "S-s-SPC f" #'er/mark-defun
 :desc "Mark Comment"   "S-s-SPC c" #'er/mark-comment
 :desc "Mark URL"   "S-s-SPC u" #'er/mark-url
 :desc "Mark ins Pairs"   "S-s-SPC i" #'er/mark-inside-pairs
 :desc "Mark ins Quotes"   "S-s-SPC I" #'er/mark-inside-quotes
 :desc "Mark out Pairs"   "S-s-SPC o" #'er/mark-outside-pairs
 :desc "Mark out Quotes"   "S-s-SPC O" #'er/mark-outside-quotes
 :desc "Mark Email"   "S-s-SPC e" #'er/mark-email
 )
(sim/flykeys-on)
#+end_src


* Neues
Farbige ausgabe von Tastenkürzel.
https://www.youtube.com/watch?v=QfN0gNaxE2U
https://github.com/michael-heerdegen/interaction-log.el
